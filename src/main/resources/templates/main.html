<!DOCTYPE html>
<html lang="ru" xmlns:th="http://www.thymeleaf.org">
<head>
  <!--  <meta charset="UTF-8" http-equiv="refresh" content="3"/>-->
  <title>HEX Grid - Canvas</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>

<canvas id="hex-grid"></canvas>

<script th:inline="javascript">
  /*<![CDATA[*/

  const json = JSON.parse([[${mapJson}]]);

  const ants = json.ants;
  const enemies = json.enemies;
  const map = json.map;
  const food = json.food;
  const turnNo = json.turnNo;
  const nextTurnIn = json.nextTurnIn;
  const home = json.home;
  const score = json.score;
  const spot = json.spot;
  /*]]>*/
</script>

<script>
  const canvas = document.getElementById("hex-grid");
  const ctx = canvas.getContext("2d");

  let width = window.innerWidth;
  let height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;

  // –ù–∞—Å—Ç—Ä–æ–π–∫–∏
  let hexSize = 35;
  let zoom = 1;
  let offsetX = 0;
  let offsetY = 0;

  let isDragging = false;
  let lastMouseX = 0;
  let lastMouseY = 0;

  const savedOffsetX = localStorage.getItem("cameraOffsetX");
  const savedOffsetY = localStorage.getItem("cameraOffsetY");
  const savedZoom = localStorage.getItem("cameraZoom");


  if (savedOffsetX !== null && savedOffsetY !== null && savedZoom !== null) {
    offsetX = parseFloat(savedOffsetX);
    offsetY = parseFloat(savedOffsetY);
    zoom = parseFloat(savedZoom);
  } else {
    // –¶–µ–Ω—Ç—Ä–æ–≤–∫–∞ –Ω–∞ –º—É—Ä–∞–≤–µ–π–Ω–∏–∫–µ, –µ—Å–ª–∏ –≤ localStorage –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö
    const homeHex = map.find(cell => cell.type === 1);
    if (homeHex) {
      const metrics = getHexMetrics(hexSize);
      const { hexWidth } = metrics;
      const { q, r } = homeHex;

      const offsetXRow = (r % 2) * (hexWidth / 2);
      const worldX = q * metrics.horizStep + offsetXRow;
      const worldY = r * metrics.vertStep;

      offsetX = -worldX;
      offsetY = -worldY;
    }
  }

  // // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ –ø–µ—Ä–≤–æ–º –≥–µ–∫—Å–µ —Å type = 1
  // const homeHex = map.find(cell => cell.type === 1);
  // if (homeHex) {
  //   const metrics = getHexMetrics(hexSize);
  //   const { hexWidth, hexHeight } = metrics;
  //   const { q, r } = homeHex;
  //
  //   // –¶–µ–Ω—Ç—Ä –≥–µ–∫—Å–∞ –≤ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
  //   const offsetXRow = (r % 2) * (hexWidth / 2);
  //   const worldX = q * metrics.horizStep + offsetXRow;
  //   const worldY = r * metrics.vertStep;
  //
  //   // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∫–∞–º–µ—Ä—É –Ω–∞ —ç—Ç–æ–º –≥–µ–∫—Å–µ
  //   offsetX = -worldX;
  //   offsetY = -worldY;
  // }

  function updateTitle() {
    document.title = `‚è≥ ${nextTurnIn.toFixed(2)} —Å–µ–∫ | üèÜ –û—á–∫–∏: ${score}`;
  }

  function drawTooltip() {
    if (!hoveredHex) return;

    const textLines = hoveredHex.infoText;
    const padding = 8;
    const lineHeight = 16;
    const boxWidth = 360;
    const boxHeight = padding * 2 + lineHeight * textLines.length;

    ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
    ctx.fillRect(hoveredHex.cx + hexSize, hoveredHex.cy - 10, boxWidth, boxHeight);

    ctx.strokeStyle = "black";
    ctx.strokeRect(hoveredHex.cx + hexSize, hoveredHex.cy - 10, boxWidth, boxHeight);

    ctx.fillStyle = "black";
    ctx.font = "14px sans-serif";

    for (let i = 0; i < textLines.length; i++) {
      ctx.fillText(textLines[i], hoveredHex.cx + hexSize + padding+170, hoveredHex.cy + i * lineHeight + 6);
    }
  }

  function saveData() {
    navigator.clipboard.writeText(infoForCopy.text.join('\r\n'));
  }

  function getHexMetrics(size) {
    const hexWidth = Math.sqrt(3) * size;
    const hexHeight = size * 2;
    const vertStep = hexHeight * 0.75;
    const horizStep = hexWidth;
    return { hexWidth, hexHeight, vertStep, horizStep };
  }

  function worldToScreen(x, y) {
    return {
      x: (x + offsetX) * zoom + width / 2,
      y: (y + offsetY) * zoom + height / 2
    };
  }

  function screenToWorld(sx, sy) {
    return {
      x: (sx - width / 2) / zoom - offsetX,
      y: (sy - height / 2) / zoom - offsetY
    };
  }

  function saveCameraState() {
    localStorage.setItem("cameraOffsetX", offsetX);
    localStorage.setItem("cameraOffsetY", offsetY);
    localStorage.setItem("cameraZoom", zoom);
  }

  function drawHexGrid() {
    ctx.clearRect(0, 0, width, height);

    const metrics = getHexMetrics(hexSize);
    const { hexWidth, hexHeight, vertStep, horizStep } = metrics;

    // –í—ã—á–∏—Å–ª—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö –º–∏—Ä–∞
    const worldLeft = (-width / 2 / zoom) - offsetX;
    const worldRight = (width / 2 / zoom) - offsetX;
    const worldTop = (-height / 2 / zoom) - offsetY;
    const worldBottom = (height / 2 / zoom) - offsetY;

    const colStart = Math.floor(worldLeft / horizStep) - 1;
    const colEnd = Math.ceil(worldRight / horizStep) + 1;
    const rowStart = Math.floor(worldTop / vertStep) - 1;
    const rowEnd = Math.ceil(worldBottom / vertStep) + 1;

    for (let row = rowStart; row < rowEnd; row++) {
      for (let col = colStart; col < colEnd; col++) {
        const offsetXRow = (row % 2) * (hexWidth / 2);
        const x = col * horizStep + offsetXRow;
        const y = row * vertStep;

        const points = [];
        for (let i = 0; i < 6; i++) {
          const angle = Math.PI / 180 * (60 * i - 30); // Pointy-topped
          const px = x + hexSize * Math.cos(angle);
          const py = y + hexSize * Math.sin(angle);
          const { x: sx, y: sy } = worldToScreen(px, py);
          points.push({ x: sx, y: sy });
        }

        // –†–∏—Å—É–µ–º —à–µ—Å—Ç–∏—É–≥–æ–ª—å–Ω–∏–∫
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < 6; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.closePath();

        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º q –∏ r, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ —ç—Ç–æ–π —è—á–µ–π–∫–µ
        const q = col;
        const r = row;

        // –ò—â–µ–º —è—á–µ–π–∫—É –≤ map
        const cell = map.find(cell => cell.q === q && cell.r === r);

        if (cell) {
          switch (cell.type) {
            case 1: ctx.fillStyle = "rgba(147,75,17,0.5)"; break; // –ú—É—Ä–∞–≤–µ–π–Ω–∏–∫
            case 2: ctx.fillStyle = "rgb(255,255,255)"; break; // –ü—É—Å—Ç–æ
            case 3: ctx.fillStyle = "rgba(32,32,147,0.5)"; break; // –ì—Ä—è–∑—å
            case 4: ctx.fillStyle = "rgba(1,255,13,0.89)"; break; // –ö–∏—Å–ª–æ—Ç–∞
            case 5: ctx.fillStyle = "rgb(255,0,0)"; break; // –ö–∞–º–Ω–∏
            default: ctx.fillStyle = "rgba(255,255,255,0.98)";
          }
          ctx.fill();
        } else {
          ctx.fillStyle = "rgba(0,0,0,0.71)";
          ctx.fill();
        }

        ctx.strokeStyle = "black";
        ctx.stroke();

        const { x: cx, y: cy } = worldToScreen(x, y);
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–±—ä–µ–∫—Ç—ã –≤ —è—á–µ–π–∫–µ
        const antsHere = ants.filter(ant => ant.q === q && ant.r === r);
        const enemiesHere = enemies.filter(ant => ant.q === q && ant.r === r);
        const foodHere = food.find(fd => fd.q === q && fd.r === r);
        const homeHere = home.find(h => h.q === q && h.r === r);

        let emoji = "";
        if (antsHere.length > 0) {
          emoji += `üêúx${antsHere.length}`;
        }

        if (enemiesHere.length > 0) {
          emoji += `üëøx${enemiesHere.length}`;
        }

        if (homeHere) {
          emoji += "üè†";
        }

        if (foodHere) {
          switch (foodHere.type) {
            case 1: emoji += "üçéx" + foodHere.amount; break;
            case 2: emoji += "üçûx" + foodHere.amount; break;
            case 3: emoji += "üçØx" + foodHere.amount; break;
            default: emoji += "üç≤x" + foodHere.amount; break;
          }
        }

        if (emoji) {
          // –°–º–∞–π–ª–∏–∫ —Å–≤–µ—Ä—Ö—É
          ctx.font = `${hexSize * 0.4}px serif`;
          ctx.fillStyle = "rgba(0, 0, 0, 0.75)";
          ctx.fillText(emoji, cx, cy - hexSize * 0.2);

          // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å–Ω–∏–∑—É
          ctx.font = "12px sans-serif";
          ctx.fillStyle = "rgba(0, 0, 0)";
          ctx.fillText(`${q},${r}`, cx, cy + hexSize * 0.3);
        } else {
          ctx.font = "12px sans-serif";
          ctx.fillStyle = "rgba(0, 0, 0)";
          ctx.fillText(`${q},${r}`, cx, cy);
        }
      }
    }
    updateTitle();
  }

  function resizeCanvas() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    drawHexGrid();
  }

  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const mouseX = e.clientX;
    const mouseY = e.clientY;
    const oldZoom = zoom;

    if (e.deltaY < 0) {
      zoom *= zoomFactor;
    } else {
      zoom /= zoomFactor;
    }

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ—á–∫—É –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π –ø—Ä–∏ –∑—É–º–µ
    const { x: wx, y: wy } = screenToWorld(mouseX, mouseY);
    offsetX -= wx * (zoom - oldZoom) / zoom;
    offsetY -= wy * (zoom - oldZoom) / zoom;

    drawHexGrid();
    saveCameraState();
  }, { passive: false });

  canvas.addEventListener("mousedown", (e) => {
    if (e.button === 0) {
      isDragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    }
  });

  window.addEventListener("mouseup", () => {
    isDragging = false;
  });

  window.addEventListener("mousemove", (e) => {
    if (isDragging) {
      const dx = (e.clientX - lastMouseX) / zoom;
      const dy = (e.clientY - lastMouseY) / zoom;
      offsetX += dx;
      offsetY += dy;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      drawHexGrid();
      saveCameraState();
    }
  });

  window.addEventListener("resize", resizeCanvas);

  window.addEventListener("dblclick", (e) => {
    saveData();
  })

  window.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const worldPos = screenToWorld(mouseX, mouseY);


    const metrics = getHexMetrics(hexSize);
    const { hexWidth, vertStep, horizStep } = metrics;

    const mouseR = Math.round(worldPos.y / vertStep);
    const offsetXRow = (mouseR % 2) * (hexWidth / 2);
    const mouseQ = Math.round((worldPos.x - offsetXRow) / horizStep);

    const cell = map.find(c => c.q === mouseQ && c.r === mouseR);

    // if (cell || map.some(a => a.q === mouseQ && a.r === mouseR)) {
    const antsHere = ants.filter(a => a.q === mouseQ && a.r === mouseR);
    const foodHere = food.filter(f => f.q === mouseQ && f.r === mouseR);
    const enemiesHere = enemies.filter(a => a.q === mouseQ && a.r === mouseR);

    const info = [`–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: ${mouseQ},${mouseR}`];
    const textForInfo = [`{"q": ${mouseQ}, "r": ${mouseR}}`];

    if (cell) {
      let typeName = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π";
      switch (cell.type) {
        case 1: typeName = "–ú—É—Ä–∞–≤–µ–π–Ω–∏–∫"; break;
        case 2: typeName = "–ü—É—Å—Ç–æ"; break;
        case 3: typeName = "–ì—Ä—è–∑—å"; break;
        case 4: typeName = "–ö–∏—Å–ª–æ—Ç–∞"; break;
        case 5: typeName = "–ö–∞–º–Ω–∏"; break;
      }
      info.push(`–ì–µ–∫—Å: ${typeName}`);
    }

    const typeNames = { 0: "–†–∞–±–æ—á–∏–π", 1: "–ë–æ–µ—Ü", 2: "–†–∞–∑–≤–µ–¥—á–∏–∫" };
    const healthTypes = {0: 130, 1: 180, 2:80};
    const foodNames = { 0: "–ù–µ—Ç", 1: "üçé", 2: "üçû", 3: "üçØ" };
    if (antsHere.length > 0) {

      antsHere.forEach(a => {
        info.push(`–ú—É—Ä–∞–≤–µ–π: ${typeNames[a.type]} (HP: ${a.health}/${healthTypes[a.type]}, –ï–¥–∞: ${foodNames[a.food.type]}=${a.food.amount})`)
      })

      textForInfo.push(antsHere
      .map(a => `${a.id}: ${typeNames[a.type] || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π'}`).join('\n'));
    }

    if (enemiesHere.length > 0) {
      enemiesHere.forEach(a => {
        info.push(`–í—Ä–∞–≥: ${typeNames[a.type]} (HP: ${a.health}/${healthTypes[a.type]}, –ï–¥–∞: ${foodNames[a.food.type]}=${a.food.amount})`)
      })
      textForInfo.push(enemiesHere
      .map(a => `${a.id}: ${typeNames[a.type] || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π'}`).join('\n'));
    }

    if (foodHere.length > 0) {
      foodHere.forEach(a => {
        info.push(`–ï–¥–∞:${foodNames[a.type]}x${a.amount}`)
      })
    }

    hoveredHex = {
      q: mouseQ,
      r: mouseR,
      cx: worldToScreen(0, 0).x - offsetX * zoom,
      cy: worldToScreen(0, 0).y - offsetY * zoom,
      infoText: info
    };

    infoForCopy = {
      text: textForInfo
    };

    drawHexGrid();
    drawTooltip();
    // } else {
    //   hoveredHex = null;
    //   drawHexGrid();
    // }
  });

  //–û—Å—Ç–∞–Ω–æ–≤–∫–∞/–∑–∞–ø—É—Å–∫ –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
  let autoRefreshEnabled = true;
  let refreshTimer = null;

  function startAutoRefresh() {
    refreshTimer = setTimeout(() => {
      location.reload();
    }, 1000); // 1 —Å–µ–∫—É–Ω–¥–∞
    autoRefreshEnabled = true;
    console.log("‚úÖ –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–∫–ª—é—á–µ–Ω–æ");
  }

  function stopAutoRefresh() {
    clearTimeout(refreshTimer);
    autoRefreshEnabled = false;
    console.log("‚è∏ –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ");
  }

  // –°—Ç–∞—Ä—Ç—É–µ–º –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
  startAutoRefresh();

  // –ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å –ø–æ –∫–ª–∞–≤–∏—à–µ Enter
  window.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      if (autoRefreshEnabled) {
        stopAutoRefresh();
      } else {
        startAutoRefresh();
      }
    }
  });

  drawHexGrid();
</script>

</body>
</html>